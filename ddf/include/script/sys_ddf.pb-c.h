/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: script/sys_ddf.proto */

#ifndef PROTOBUF_C_script_2fsys_5fddf_2eproto__INCLUDED
#define PROTOBUF_C_script_2fsys_5fddf_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1000000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1004001 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif

#include "ddf/ddf_extensions.pb-c.h"
#include "ddf/ddf_math.pb-c.h"

typedef struct DmSystemDDF__Exit DmSystemDDF__Exit;
typedef struct DmSystemDDF__ToggleProfile DmSystemDDF__ToggleProfile;
typedef struct DmSystemDDF__TogglePhysicsDebug DmSystemDDF__TogglePhysicsDebug;
typedef struct DmSystemDDF__StartRecord DmSystemDDF__StartRecord;
typedef struct DmSystemDDF__StopRecord DmSystemDDF__StopRecord;
typedef struct DmSystemDDF__Reboot DmSystemDDF__Reboot;
typedef struct DmSystemDDF__SetVsync DmSystemDDF__SetVsync;
typedef struct DmSystemDDF__SetUpdateFrequency DmSystemDDF__SetUpdateFrequency;


/* --- enums --- */


/* --- messages --- */

/*
 *# exits application
 * Terminates the game application and reports the specified <code>code</code> to the OS.
 * This message can only be sent to the designated `@system` socket.
 * @message
 * @name exit
 * @param code [type:number] exit code to report to the OS, 0 means clean exit
 * @examples
 * This examples demonstrates how to exit the application when some kind of quit messages is received (maybe from gui or similar):
 * ```lua
 * function on_message(self, message_id, message, sender)
 *     if message_id == hash("quit") then
 *         msg.post("@system:", "exit", {code = 0})
 *     end
 * end
 * ```
 */
struct  DmSystemDDF__Exit
{
  ProtobufCMessage base;
  int32_t code;
};
#define DM_SYSTEM_DDF__EXIT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dm_system_ddf__exit__descriptor) \
    , 0 }


/*
 *# shows/hides the on-screen profiler
 * Toggles the on-screen profiler.
 * The profiler is a real-time tool that shows the numbers of milliseconds spent
 * in each scope per frame as well as counters. The profiler is very useful for
 * tracking down performance and resource problems.
 * In addition to the on-screen profiler, Defold includes a web-based profiler that
 * allows you to sample a series of data points and then analyze them in detail.
 * The web profiler is available at `http://<device IP>:8002` where <device IP> is
 * the IP address of the device you are running your game on.
 * This message can only be sent to the designated `@system` socket.
 * @message
 * @name toggle_profile
 * @examples
 * ```lua
 * msg.post("@system:", "toggle_profile")
 * ```
 */
struct  DmSystemDDF__ToggleProfile
{
  ProtobufCMessage base;
};
#define DM_SYSTEM_DDF__TOGGLE_PROFILE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dm_system_ddf__toggle_profile__descriptor) \
     }


/*
 *# shows/hides the on-screen physics visual debugging
 * Toggles the on-screen physics visual debugging mode which is very useful for
 * tracking down issues related to physics. This mode visualizes
 * all collision object shapes and normals at detected contact points. Toggling
 * this mode on is equal to setting `physics.debug` in the "game.project" settings,
 * but set in run-time.
 * This message can only be sent to the designated `@system` socket.
 * @message
 * @name toggle_physics_debug
 * @examples
 * @examples
 * ```lua
 * msg.post("@system:", "toggle_physics_debug")
 * ```
 */
struct  DmSystemDDF__TogglePhysicsDebug
{
  ProtobufCMessage base;
};
#define DM_SYSTEM_DDF__TOGGLE_PHYSICS_DEBUG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dm_system_ddf__toggle_physics_debug__descriptor) \
     }


/*
 *# starts video recording
 * Starts video recording of the game frame-buffer to file. Current video format is the
 * open vp8 codec in the ivf container. It's possible to upload this format directly
 * to YouTube. The VLC video player has native support but with the known issue that
 * not the entire file is played back. It's probably an issue with VLC.
 * The Miro Video Converter has support for vp8/ivf.
 * [icon:macos] [icon:windows] [icon:linux] Video recording is only supported on desktop platforms.
 * [icon:attention] Audio is currently not supported
 * [icon:attention] Window width and height must be a multiple of 8 to be able to record video.
 * This message can only be sent to the designated `@system` socket.
 * @message
 * @name start_record
 * @param file_name [type:string] file name to write the video to
 * @param frame_period [type:number] frame period to record, ie write every nth frame. Default value is `2`
 * @param fps [type:number] frames per second. Playback speed for the video. Default value is `30`. The fps value doens't affect the recording. It's only meta-data in the written video file.
 * @examples
 * Record a video in 30 fps given that the native game fps is 60:
 * ```lua
 * msg.post("@system:", "start_record", { file_name = "test_rec.ivf" } )
 * ```
 * To write a video in 60 fps given that the native game fps is 60:
 * ```lua
 * msg.post("@system:", "start_record", { file_name = "test_rec.ivf", frame_period = 1, fps = 60 } )
 * ```
 */
struct  DmSystemDDF__StartRecord
{
  ProtobufCMessage base;
  char *file_name;
  protobuf_c_boolean has_frame_period;
  int32_t frame_period;
  protobuf_c_boolean has_fps;
  int32_t fps;
};
#define DM_SYSTEM_DDF__START_RECORD__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dm_system_ddf__start_record__descriptor) \
    , NULL, 0, 2, 0, 30 }


/*
 *# stop current video recording
 * Stops the currently active video recording.
 * [icon:macos] [icon:windows] [icon:linux] Video recording is only supported on desktop platforms.
 * This message can only be sent to the designated `@system` socket.
 * @message
 * @name stop_record
 * @examples
 * ```lua
 * msg.post("@system:", "stop_record")
 * ```
 */
struct  DmSystemDDF__StopRecord
{
  ProtobufCMessage base;
};
#define DM_SYSTEM_DDF__STOP_RECORD__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dm_system_ddf__stop_record__descriptor) \
     }


/*
 *# reboot engine with arguments
 * Reboots the game engine with a specified set of arguments.
 * Arguments will be translated into command line arguments. Sending the reboot
 * command is equivalent to starting the engine with the same arguments.
 * On startup the engine reads configuration from "game.project" in the
 * project root.
 * This message can only be sent to the designated `@system` socket.
 * @message
 * @name reboot
 * @param arg1 [type:string] argument 1
 * @param arg2 [type:string] argument 2
 * @param arg3 [type:string] argument 3
 * @param arg4 [type:string] argument 4
 * @param arg5 [type:string] argument 5
 * @param arg6 [type:string] argument 6
 * @examples
 * How to reboot engine with a specific bootstrap collection.
 * ```lua
 * local arg1 = '--config=bootstrap.main_collection=/my.collectionc'
 * local arg2 = 'build/default/game.projectc'
 * msg.post("@system:", "reboot", {arg1 = arg1, arg2 = arg2})
 * ```
 */
struct  DmSystemDDF__Reboot
{
  ProtobufCMessage base;
  /*
   * We don't support repeated value in script_ddf. Probably for a good reason.
   */
  char *arg1;
  char *arg2;
  char *arg3;
  char *arg4;
  char *arg5;
  char *arg6;
};
#define DM_SYSTEM_DDF__REBOOT__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dm_system_ddf__reboot__descriptor) \
    , NULL, NULL, NULL, NULL, NULL, NULL }


/*
 *# set vsync swap interval
 * Set the vsync swap interval. The interval with which to swap the front and back buffers
 * in sync with vertical blanks (v-blank), the hardware event where the screen image is updated
 * with data from the front buffer. A value of 1 swaps the buffers at every v-blank, a value of
 * 2 swaps the buffers every other v-blank and so on. A value of 0 disables waiting for v-blank
 * before swapping the buffers. Default value is 1.
 * When setting the swap interval to 0 and having `vsync` disabled in
 * "game.project", the engine will try to respect the set frame cap value from
 * "game.project" in software instead.
 * This setting may be overridden by driver settings.
 * This message can only be sent to the designated `@system` socket.
 * @message
 * @name set_vsync
 * @param swap_interval target swap interval.
 * @examples
 * <pre>
 * msg.post("@system:", "set_vsync", { swap_interval = 1 } )
 * </pre>
 */
struct  DmSystemDDF__SetVsync
{
  ProtobufCMessage base;
  int32_t swap_interval;
};
#define DM_SYSTEM_DDF__SET_VSYNC__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dm_system_ddf__set_vsync__descriptor) \
    , 1 }


/*
 *# set update frequency
 * Set game update-frequency (frame cap). This option is equivalent to `display.update_frequency` in
 * the "game.project" settings but set in run-time. If `Vsync` checked in "game.project", the rate will
 * be clamped to a swap interval that matches any detected main monitor refresh rate. If `Vsync` is
 * unchecked the engine will try to respect the rate in software using timers. There is no
 * guarantee that the frame cap will be achieved depending on platform specifics and hardware settings.
 * This message can only be sent to the designated `@system` socket.
 * @message
 * @name set_update_frequency
 * @param frequency target frequency. 60 for 60 fps
 * @examples
 * <pre>
 * msg.post("@system:", "set_update_frequency", { frequency = 60 } )
 * </pre>
 */
struct  DmSystemDDF__SetUpdateFrequency
{
  ProtobufCMessage base;
  int32_t frequency;
};
#define DM_SYSTEM_DDF__SET_UPDATE_FREQUENCY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dm_system_ddf__set_update_frequency__descriptor) \
    , 0 }


/* DmSystemDDF__Exit methods */
void   dm_system_ddf__exit__init
                     (DmSystemDDF__Exit         *message);
size_t dm_system_ddf__exit__get_packed_size
                     (const DmSystemDDF__Exit   *message);
size_t dm_system_ddf__exit__pack
                     (const DmSystemDDF__Exit   *message,
                      uint8_t             *out);
size_t dm_system_ddf__exit__pack_to_buffer
                     (const DmSystemDDF__Exit   *message,
                      ProtobufCBuffer     *buffer);
DmSystemDDF__Exit *
       dm_system_ddf__exit__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   dm_system_ddf__exit__free_unpacked
                     (DmSystemDDF__Exit *message,
                      ProtobufCAllocator *allocator);
/* DmSystemDDF__ToggleProfile methods */
void   dm_system_ddf__toggle_profile__init
                     (DmSystemDDF__ToggleProfile         *message);
size_t dm_system_ddf__toggle_profile__get_packed_size
                     (const DmSystemDDF__ToggleProfile   *message);
size_t dm_system_ddf__toggle_profile__pack
                     (const DmSystemDDF__ToggleProfile   *message,
                      uint8_t             *out);
size_t dm_system_ddf__toggle_profile__pack_to_buffer
                     (const DmSystemDDF__ToggleProfile   *message,
                      ProtobufCBuffer     *buffer);
DmSystemDDF__ToggleProfile *
       dm_system_ddf__toggle_profile__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   dm_system_ddf__toggle_profile__free_unpacked
                     (DmSystemDDF__ToggleProfile *message,
                      ProtobufCAllocator *allocator);
/* DmSystemDDF__TogglePhysicsDebug methods */
void   dm_system_ddf__toggle_physics_debug__init
                     (DmSystemDDF__TogglePhysicsDebug         *message);
size_t dm_system_ddf__toggle_physics_debug__get_packed_size
                     (const DmSystemDDF__TogglePhysicsDebug   *message);
size_t dm_system_ddf__toggle_physics_debug__pack
                     (const DmSystemDDF__TogglePhysicsDebug   *message,
                      uint8_t             *out);
size_t dm_system_ddf__toggle_physics_debug__pack_to_buffer
                     (const DmSystemDDF__TogglePhysicsDebug   *message,
                      ProtobufCBuffer     *buffer);
DmSystemDDF__TogglePhysicsDebug *
       dm_system_ddf__toggle_physics_debug__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   dm_system_ddf__toggle_physics_debug__free_unpacked
                     (DmSystemDDF__TogglePhysicsDebug *message,
                      ProtobufCAllocator *allocator);
/* DmSystemDDF__StartRecord methods */
void   dm_system_ddf__start_record__init
                     (DmSystemDDF__StartRecord         *message);
size_t dm_system_ddf__start_record__get_packed_size
                     (const DmSystemDDF__StartRecord   *message);
size_t dm_system_ddf__start_record__pack
                     (const DmSystemDDF__StartRecord   *message,
                      uint8_t             *out);
size_t dm_system_ddf__start_record__pack_to_buffer
                     (const DmSystemDDF__StartRecord   *message,
                      ProtobufCBuffer     *buffer);
DmSystemDDF__StartRecord *
       dm_system_ddf__start_record__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   dm_system_ddf__start_record__free_unpacked
                     (DmSystemDDF__StartRecord *message,
                      ProtobufCAllocator *allocator);
/* DmSystemDDF__StopRecord methods */
void   dm_system_ddf__stop_record__init
                     (DmSystemDDF__StopRecord         *message);
size_t dm_system_ddf__stop_record__get_packed_size
                     (const DmSystemDDF__StopRecord   *message);
size_t dm_system_ddf__stop_record__pack
                     (const DmSystemDDF__StopRecord   *message,
                      uint8_t             *out);
size_t dm_system_ddf__stop_record__pack_to_buffer
                     (const DmSystemDDF__StopRecord   *message,
                      ProtobufCBuffer     *buffer);
DmSystemDDF__StopRecord *
       dm_system_ddf__stop_record__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   dm_system_ddf__stop_record__free_unpacked
                     (DmSystemDDF__StopRecord *message,
                      ProtobufCAllocator *allocator);
/* DmSystemDDF__Reboot methods */
void   dm_system_ddf__reboot__init
                     (DmSystemDDF__Reboot         *message);
size_t dm_system_ddf__reboot__get_packed_size
                     (const DmSystemDDF__Reboot   *message);
size_t dm_system_ddf__reboot__pack
                     (const DmSystemDDF__Reboot   *message,
                      uint8_t             *out);
size_t dm_system_ddf__reboot__pack_to_buffer
                     (const DmSystemDDF__Reboot   *message,
                      ProtobufCBuffer     *buffer);
DmSystemDDF__Reboot *
       dm_system_ddf__reboot__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   dm_system_ddf__reboot__free_unpacked
                     (DmSystemDDF__Reboot *message,
                      ProtobufCAllocator *allocator);
/* DmSystemDDF__SetVsync methods */
void   dm_system_ddf__set_vsync__init
                     (DmSystemDDF__SetVsync         *message);
size_t dm_system_ddf__set_vsync__get_packed_size
                     (const DmSystemDDF__SetVsync   *message);
size_t dm_system_ddf__set_vsync__pack
                     (const DmSystemDDF__SetVsync   *message,
                      uint8_t             *out);
size_t dm_system_ddf__set_vsync__pack_to_buffer
                     (const DmSystemDDF__SetVsync   *message,
                      ProtobufCBuffer     *buffer);
DmSystemDDF__SetVsync *
       dm_system_ddf__set_vsync__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   dm_system_ddf__set_vsync__free_unpacked
                     (DmSystemDDF__SetVsync *message,
                      ProtobufCAllocator *allocator);
/* DmSystemDDF__SetUpdateFrequency methods */
void   dm_system_ddf__set_update_frequency__init
                     (DmSystemDDF__SetUpdateFrequency         *message);
size_t dm_system_ddf__set_update_frequency__get_packed_size
                     (const DmSystemDDF__SetUpdateFrequency   *message);
size_t dm_system_ddf__set_update_frequency__pack
                     (const DmSystemDDF__SetUpdateFrequency   *message,
                      uint8_t             *out);
size_t dm_system_ddf__set_update_frequency__pack_to_buffer
                     (const DmSystemDDF__SetUpdateFrequency   *message,
                      ProtobufCBuffer     *buffer);
DmSystemDDF__SetUpdateFrequency *
       dm_system_ddf__set_update_frequency__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   dm_system_ddf__set_update_frequency__free_unpacked
                     (DmSystemDDF__SetUpdateFrequency *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*DmSystemDDF__Exit_Closure)
                 (const DmSystemDDF__Exit *message,
                  void *closure_data);
typedef void (*DmSystemDDF__ToggleProfile_Closure)
                 (const DmSystemDDF__ToggleProfile *message,
                  void *closure_data);
typedef void (*DmSystemDDF__TogglePhysicsDebug_Closure)
                 (const DmSystemDDF__TogglePhysicsDebug *message,
                  void *closure_data);
typedef void (*DmSystemDDF__StartRecord_Closure)
                 (const DmSystemDDF__StartRecord *message,
                  void *closure_data);
typedef void (*DmSystemDDF__StopRecord_Closure)
                 (const DmSystemDDF__StopRecord *message,
                  void *closure_data);
typedef void (*DmSystemDDF__Reboot_Closure)
                 (const DmSystemDDF__Reboot *message,
                  void *closure_data);
typedef void (*DmSystemDDF__SetVsync_Closure)
                 (const DmSystemDDF__SetVsync *message,
                  void *closure_data);
typedef void (*DmSystemDDF__SetUpdateFrequency_Closure)
                 (const DmSystemDDF__SetUpdateFrequency *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor dm_system_ddf__exit__descriptor;
extern const ProtobufCMessageDescriptor dm_system_ddf__toggle_profile__descriptor;
extern const ProtobufCMessageDescriptor dm_system_ddf__toggle_physics_debug__descriptor;
extern const ProtobufCMessageDescriptor dm_system_ddf__start_record__descriptor;
extern const ProtobufCMessageDescriptor dm_system_ddf__stop_record__descriptor;
extern const ProtobufCMessageDescriptor dm_system_ddf__reboot__descriptor;
extern const ProtobufCMessageDescriptor dm_system_ddf__set_vsync__descriptor;
extern const ProtobufCMessageDescriptor dm_system_ddf__set_update_frequency__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_script_2fsys_5fddf_2eproto__INCLUDED */
