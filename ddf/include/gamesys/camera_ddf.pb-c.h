/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: gamesys/camera_ddf.proto */

#ifndef PROTOBUF_C_gamesys_2fcamera_5fddf_2eproto__INCLUDED
#define PROTOBUF_C_gamesys_2fcamera_5fddf_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1000000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1004001 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif

#include "ddf/ddf_extensions.pb-c.h"
#include "ddf/ddf_math.pb-c.h"

typedef struct DmGamesysDDF__CameraDesc DmGamesysDDF__CameraDesc;
typedef struct DmGamesysDDF__SetCamera DmGamesysDDF__SetCamera;
typedef struct DmGamesysDDF__AcquireCameraFocus DmGamesysDDF__AcquireCameraFocus;
typedef struct DmGamesysDDF__ReleaseCameraFocus DmGamesysDDF__ReleaseCameraFocus;


/* --- enums --- */


/* --- messages --- */

struct  DmGamesysDDF__CameraDesc
{
  ProtobufCMessage base;
  float aspect_ratio;
  float fov;
  float near_z;
  float far_z;
  protobuf_c_boolean has_auto_aspect_ratio;
  uint32_t auto_aspect_ratio;
  protobuf_c_boolean has_orthographic_projection;
  uint32_t orthographic_projection;
  protobuf_c_boolean has_orthographic_zoom;
  float orthographic_zoom;
};
#define DM_GAMESYS_DDF__CAMERA_DESC__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dm_gamesys_ddf__camera_desc__descriptor) \
    , 0, 0, 0, 0, 0, 0u, 0, 0u, 0, 1 }


/*
 *# sets camera properties
 * <p>
 * Post this message to a camera-component to set its properties at run-time.
 * </p>
 * @message
 * @name set_camera
 * @param aspect_ratio [type:number] aspect ratio of the screen (width divided by height)
 * @param fov [type:number] field of view of the lens, measured as the angle in radians between the right and left edge
 * @param near_z [type:number] position of the near clipping plane (distance from camera along relative z)
 * @param far_z [type:number] position of the far clipping plane (distance from camera along relative z)
 * @param orthographic_projection [type:bool] set to use an orthographic projection
 * @param orthographic_zoom [type:number] zoom level when the camera is using an orthographic projection
 * @examples
 * In the examples, it is assumed that the instance of the script has a camera-component with id "camera".
 * ```lua
 * msg.post("#camera", "set_camera", {aspect_ratio = 16/9, fov = math.pi * 0.5, near_z = 0.1, far_z = 500})
 * ```
 */
struct  DmGamesysDDF__SetCamera
{
  ProtobufCMessage base;
  float aspect_ratio;
  float fov;
  float near_z;
  float far_z;
  protobuf_c_boolean has_orthographic_projection;
  uint32_t orthographic_projection;
  protobuf_c_boolean has_orthographic_zoom;
  float orthographic_zoom;
};
#define DM_GAMESYS_DDF__SET_CAMERA__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dm_gamesys_ddf__set_camera__descriptor) \
    , 0, 0, 0, 0, 0, 0u, 0, 1 }


/*
 *# makes the receiving camera become the active camera
 * Post this message to a camera-component to activate it.
 * Several cameras can be active at the same time, but only the camera that was last activated will be used for rendering.
 * When the camera is deactivated (see <code>release_camera_focus</code>), the previously activated camera will again be used for rendering automatically.
 * The reason it is called "camera focus" is the similarity to how acquiring input focus works (see <code>acquire_input_focus</code>).
 * @message
 * @name acquire_camera_focus
 * @examples
 * In the examples, it is assumed that the instance of the script has a camera-component with id "camera".
 * ```lua
 * msg.post("#camera", "acquire_camera_focus")
 * ```
 */
struct  DmGamesysDDF__AcquireCameraFocus
{
  ProtobufCMessage base;
};
#define DM_GAMESYS_DDF__ACQUIRE_CAMERA_FOCUS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dm_gamesys_ddf__acquire_camera_focus__descriptor) \
     }


/*
 *# deactivates the receiving camera
 * <p>
 * Post this message to a camera-component to deactivate it. The camera is then removed from the active cameras.
 * See <code>acquire_camera_focus</code> for more information how the active cameras are used in rendering.
 * </p>
 * @message
 * @name release_camera_focus
 * @examples
 * In the examples, it is assumed that the instance of the script has a camera-component with id "camera".
 * ```lua
 * msg.post("#camera", "release_camera_focus")
 * ```
 */
struct  DmGamesysDDF__ReleaseCameraFocus
{
  ProtobufCMessage base;
};
#define DM_GAMESYS_DDF__RELEASE_CAMERA_FOCUS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dm_gamesys_ddf__release_camera_focus__descriptor) \
     }


/* DmGamesysDDF__CameraDesc methods */
void   dm_gamesys_ddf__camera_desc__init
                     (DmGamesysDDF__CameraDesc         *message);
size_t dm_gamesys_ddf__camera_desc__get_packed_size
                     (const DmGamesysDDF__CameraDesc   *message);
size_t dm_gamesys_ddf__camera_desc__pack
                     (const DmGamesysDDF__CameraDesc   *message,
                      uint8_t             *out);
size_t dm_gamesys_ddf__camera_desc__pack_to_buffer
                     (const DmGamesysDDF__CameraDesc   *message,
                      ProtobufCBuffer     *buffer);
DmGamesysDDF__CameraDesc *
       dm_gamesys_ddf__camera_desc__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   dm_gamesys_ddf__camera_desc__free_unpacked
                     (DmGamesysDDF__CameraDesc *message,
                      ProtobufCAllocator *allocator);
/* DmGamesysDDF__SetCamera methods */
void   dm_gamesys_ddf__set_camera__init
                     (DmGamesysDDF__SetCamera         *message);
size_t dm_gamesys_ddf__set_camera__get_packed_size
                     (const DmGamesysDDF__SetCamera   *message);
size_t dm_gamesys_ddf__set_camera__pack
                     (const DmGamesysDDF__SetCamera   *message,
                      uint8_t             *out);
size_t dm_gamesys_ddf__set_camera__pack_to_buffer
                     (const DmGamesysDDF__SetCamera   *message,
                      ProtobufCBuffer     *buffer);
DmGamesysDDF__SetCamera *
       dm_gamesys_ddf__set_camera__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   dm_gamesys_ddf__set_camera__free_unpacked
                     (DmGamesysDDF__SetCamera *message,
                      ProtobufCAllocator *allocator);
/* DmGamesysDDF__AcquireCameraFocus methods */
void   dm_gamesys_ddf__acquire_camera_focus__init
                     (DmGamesysDDF__AcquireCameraFocus         *message);
size_t dm_gamesys_ddf__acquire_camera_focus__get_packed_size
                     (const DmGamesysDDF__AcquireCameraFocus   *message);
size_t dm_gamesys_ddf__acquire_camera_focus__pack
                     (const DmGamesysDDF__AcquireCameraFocus   *message,
                      uint8_t             *out);
size_t dm_gamesys_ddf__acquire_camera_focus__pack_to_buffer
                     (const DmGamesysDDF__AcquireCameraFocus   *message,
                      ProtobufCBuffer     *buffer);
DmGamesysDDF__AcquireCameraFocus *
       dm_gamesys_ddf__acquire_camera_focus__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   dm_gamesys_ddf__acquire_camera_focus__free_unpacked
                     (DmGamesysDDF__AcquireCameraFocus *message,
                      ProtobufCAllocator *allocator);
/* DmGamesysDDF__ReleaseCameraFocus methods */
void   dm_gamesys_ddf__release_camera_focus__init
                     (DmGamesysDDF__ReleaseCameraFocus         *message);
size_t dm_gamesys_ddf__release_camera_focus__get_packed_size
                     (const DmGamesysDDF__ReleaseCameraFocus   *message);
size_t dm_gamesys_ddf__release_camera_focus__pack
                     (const DmGamesysDDF__ReleaseCameraFocus   *message,
                      uint8_t             *out);
size_t dm_gamesys_ddf__release_camera_focus__pack_to_buffer
                     (const DmGamesysDDF__ReleaseCameraFocus   *message,
                      ProtobufCBuffer     *buffer);
DmGamesysDDF__ReleaseCameraFocus *
       dm_gamesys_ddf__release_camera_focus__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   dm_gamesys_ddf__release_camera_focus__free_unpacked
                     (DmGamesysDDF__ReleaseCameraFocus *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*DmGamesysDDF__CameraDesc_Closure)
                 (const DmGamesysDDF__CameraDesc *message,
                  void *closure_data);
typedef void (*DmGamesysDDF__SetCamera_Closure)
                 (const DmGamesysDDF__SetCamera *message,
                  void *closure_data);
typedef void (*DmGamesysDDF__AcquireCameraFocus_Closure)
                 (const DmGamesysDDF__AcquireCameraFocus *message,
                  void *closure_data);
typedef void (*DmGamesysDDF__ReleaseCameraFocus_Closure)
                 (const DmGamesysDDF__ReleaseCameraFocus *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor dm_gamesys_ddf__camera_desc__descriptor;
extern const ProtobufCMessageDescriptor dm_gamesys_ddf__set_camera__descriptor;
extern const ProtobufCMessageDescriptor dm_gamesys_ddf__acquire_camera_focus__descriptor;
extern const ProtobufCMessageDescriptor dm_gamesys_ddf__release_camera_focus__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_gamesys_2fcamera_5fddf_2eproto__INCLUDED */
